package atomicCompositions.analysis;

/*******************************************************************************
 * Copyright (c) 2002 - 2006 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

import java.io.IOException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;

import soot.Body;
import soot.Unit;
import soot.jimple.Stmt;
import utils.SootHelper;

import com.ibm.wala.classLoader.IBytecodeMethod;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.classLoader.ShrikeBTMethod;
import com.ibm.wala.classLoader.ShrikeCTMethod;
import com.ibm.wala.core.tests.callGraph.CallGraphTestUtil;
import com.ibm.wala.core.tests.slicer.SlicerTest;
import com.ibm.wala.examples.drivers.PDFSDG;
import com.ibm.wala.ipa.callgraph.AnalysisCache;
import com.ibm.wala.ipa.callgraph.AnalysisOptions;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.CallGraphBuilder;
import com.ibm.wala.ipa.callgraph.Entrypoint;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.slicer.HeapStatement;
import com.ibm.wala.ipa.slicer.NormalReturnCaller;
import com.ibm.wala.ipa.slicer.NormalStatement;
import com.ibm.wala.ipa.slicer.ParamCallee;
import com.ibm.wala.ipa.slicer.ParamCaller;
import com.ibm.wala.ipa.slicer.SDG;
import com.ibm.wala.ipa.slicer.Slicer;
import com.ibm.wala.ipa.slicer.Slicer.ControlDependenceOptions;
import com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions;
import com.ibm.wala.ipa.slicer.Statement;
import com.ibm.wala.ipa.slicer.Statement.Kind;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.SSAAbstractInvokeInstruction;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAInvokeInstruction;
import com.ibm.wala.types.TypeReference;
import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.WalaException;
import com.ibm.wala.util.collections.Filter;
import com.ibm.wala.util.config.AnalysisScopeReader;
import com.ibm.wala.util.debug.Assertions;
import com.ibm.wala.util.graph.Graph;
import com.ibm.wala.util.graph.GraphIntegrity;
import com.ibm.wala.util.graph.GraphIntegrity.UnsoundGraphException;
import com.ibm.wala.util.graph.GraphSlicer;
import com.ibm.wala.util.intset.IntSet;
import com.ibm.wala.util.io.CommandLine;
import com.ibm.wala.util.io.FileProvider;
import com.ibm.wala.viz.NodeDecorator;

/**
 * 
 * This simple example WALA application computes a slice (see {@link Slicer})
 * and fires off the PDF viewer to view a dot-ted representation of the slice.
 * 
 * This is an example program on how to use the slicer.
 * 
 * See the 'PDFSlice' launcher included in the 'launchers' directory.
 * 
 * @see Slicer
 * @author sfink
 */
public class WalaSlicerTransformer {

	/**
	 * Name of the postscript file generated by dot
	 */

	/**
	 * Usage: PDFSlice -appJar [jar file name] -mainClass [main class]
	 * -srcCaller [method name] -srcCallee [method name] -dd [data dependence
	 * options] -cd [control dependence options] -dir [forward|backward]
	 * 
	 * <ul>
	 * <li>"jar file name" should be something like
	 * "c:/temp/testdata/java_cup.jar"
	 * <li>"main class" should beshould be something like
	 * "c:/temp/testdata/java_cup.jar"
	 * <li>"method name" should be the name of a method. This takes a slice from
	 * the statement that calls "srcCallee" from "srcCaller"
	 * <li>"data dependence options" can be one of "-full", "-no_base_ptrs",
	 * "-no_base_no_heap", "-no_heap", "-no_base_no_heap_no_cast", or "-none".
	 * </ul>
	 * 
	 * @throws CancelException
	 * @throws IllegalArgumentException
	 * @throws IOException
	 * 
	 * @see com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions <li>
	 *      "control dependence options" can be "-full" or "-none" <li>the -dir
	 *      argument tells whether to compute a forwards or backwards slice.
	 *      </ul>
	 * 
	 */
	// appJar can be a path. 
	public static void main(String[] args) throws Exception {
		String appjar = "/Users/charlesz/git/git4api/APIDesigner/benchmarks/Test/bin";
		String mainclass = "LClientClass";
		String callerMethod = "clientMethod";
		String calleeMethod = "getLevel";

		boolean backward = false;
		String datadepOption = "no_base_no_heap";
		String controldepOption = "no_exceptional_edges";
		//   FULL("full"), NONE("none"), NO_EXCEPTIONAL_EDGES("no_exceptional_edges");

		sliceWholeMethod(appjar, mainclass, callerMethod, backward,
				PDFSDG.getDataDependenceOptions(datadepOption),
				PDFSDG.getControlDependenceOptions(controldepOption));
	}

	public static void sliceWholeMethod(String appJar, String mainClass,
			String srcCaller, boolean goBackward,
			DataDependenceOptions dOptions, ControlDependenceOptions cOptions)
			throws Exception {
		// create an analysis scope representing the appJar as a J2SE application
		if (!prepared)
			prepareSDG(appJar, mainClass, dOptions, cOptions);
		// find the call statement of interest
		Set<Statement> statements = getInvokeStatements(cg, srcCaller);
		for (Statement s : statements) {
			Collection<Statement> slice = null;
			if (goBackward) {
				slice = Slicer.computeBackwardSlice(s, cg,
						builder.getPointerAnalysis(), dOptions, cOptions);
			} else {
				// for forward slices ... we actually slice from the return value of
				// calls.
				try {
					s = getReturnStatementForCall(s);
					slice = Slicer.computeForwardSlice(s, cg,
							builder.getPointerAnalysis(), dOptions, cOptions);
					System.out.println("compute the deps of :" + s);

					for (Statement stmt : slice) {
						if (stmt instanceof NormalStatement
								&& sameMethod(stmt, s)
								&& isInvoke((NormalStatement) stmt)) {
							lpxzPrint((NormalStatement) stmt);
							System.out.println("line NO:" + getLineNo(stmt));
						}
					}
				} catch (Exception e) {
					continue; // analyze the next invoke. ignore the current one.
				}
			}

		}

		// compute the slice as a collection of statements

	}

	//SSAInvokeInstruction
	public static int getLineNo(CGNode n, SSAInvokeInstruction s) {
		int src_line_number = -1;
		{ // ignore special kinds of statements
			IntSet indices = n.getIR().getCallInstructionIndices(
					((SSAInvokeInstruction) s).getCallSite());

			int bcIndex, instructionIndex = indices.intIterator().next();
			try {
				IMethod iMethod = n.getMethod();
				bcIndex = ((IBytecodeMethod) iMethod)
						.getBytecodeIndex(instructionIndex);
				try {
					src_line_number = n.getMethod().getLineNumber(bcIndex);
					//					System.err.println("Source line number = "
					//							+ src_line_number);
				} catch (Throwable e) {
					System.err.println("Bytecode index no good");
					System.err.println(e.getMessage());
				}
			} catch (Throwable e) {
				System.err
						.println("it's probably not a BT method (e.g. it's a fakeroot method)");
				System.err.println(e.getMessage());
			}
		}
		return src_line_number;
	}

	public static int getLineNo(Statement s) {
		int src_line_number = -1;
		if (s.getKind() == Statement.Kind.NORMAL) { // ignore special kinds of statements
			int bcIndex, instructionIndex = ((NormalStatement) s)
					.getInstructionIndex();
			try {
				IMethod iMethod = s.getNode().getMethod();
				bcIndex = ((IBytecodeMethod) iMethod)
						.getBytecodeIndex(instructionIndex);
				try {
					src_line_number = s.getNode().getMethod()
							.getLineNumber(bcIndex);
					System.err.println("Source line number = "
							+ src_line_number);
				} catch (Throwable e) {
					System.err.println("Bytecode index no good");
					System.err.println(e.getMessage());
				}
			} catch (Throwable e) {
				System.err
						.println("it's probably not a BT method (e.g. it's a fakeroot method)");
				System.err.println(e.getMessage());
			}
		}
		return src_line_number;
	}

	// if it is parsed from the source, not the bytecode.
	//	if (s.getKind() == Statement.Kind.NORMAL) {
	//		  int instructionIndex = ((NormalStatement) s).getInstructionIndex();
	//		  int lineNum = ((ConcreteJavaMethod) s.getNode().getMethod()).getLineNumber(instructionIndex);
	//		  System.out.println("Source line number = " + lineNum );
	//		}

	private static void lpxzPrint(NormalStatement stmt) {
		System.out.println("instr: " + stmt.getInstruction()
				+ "      container method:"
				+ stmt.getNode().getMethod().getName());

	}

	private static boolean isInvoke(NormalStatement stmt) {
		return stmt.getInstruction() instanceof SSAInvokeInstruction;
	}

	private static boolean sameMethod(Statement stmt, Statement s) {

		return s.getNode().equals(stmt.getNode());

	}

	private static Set<Statement> getInvokeStatements(CallGraph cg2,
			String srcCaller) {
		Set<Statement> ret = new HashSet<Statement>();
		CGNode callerNode = SlicerTest.findMethod(cg, srcCaller);

		IR ir = callerNode.getIR();
		for (Iterator<SSAInstruction> it = ir.iterateAllInstructions(); it
				.hasNext();) {
			SSAInstruction sInstruction = it.next();
			if (sInstruction instanceof SSAInvokeInstruction) {
				SSAInvokeInstruction call = (SSAInvokeInstruction) sInstruction;
				Statement s = getTheInvokeStatement(call, ir, callerNode);
				ret.add(s);
			}

		}
		return ret;
	}

	private static Statement getTheInvokeStatement(SSAInvokeInstruction call,
			IR ir, CGNode n) {
		IntSet indices = ir
				.getCallInstructionIndices(((SSAInvokeInstruction) call)
						.getCallSite());
		Assertions.productionAssertion(indices.size() == 1,
				"expected 1 but got " + indices.size());
		return new NormalStatement(n, indices.intIterator().next());
	}

	static CallGraphBuilder			builder;
	static CallGraph				cg;
	static SDG						sdg;
	static boolean					prepared	= false;
	static DataDependenceOptions	datadepOptions;
	static ControlDependenceOptions	controldepOptions;

	public static boolean isWalaPrepared() {
		return prepared;
	}

	public static void prepareSDGAllMainEntries(String appJar,
			DataDependenceOptions dOptions, ControlDependenceOptions cOptions)
			throws Exception {
		AnalysisScope scope = AnalysisScopeReader.makeJavaBinaryAnalysisScope(
				appJar, (new FileProvider())
						.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));

		// build a class hierarchy, call graph, and system dependence graph
		ClassHierarchy cha = ClassHierarchy.make(scope);
		Iterable<Entrypoint> entrypoints = com.ibm.wala.ipa.callgraph.impl.Util
				.makeMainEntrypoints(scope, cha);
		AnalysisOptions options = CallGraphTestUtil.makeAnalysisOptions(scope,
				entrypoints);
		builder = Util.makeVanillaZeroOneCFABuilder(options,
				new AnalysisCache(), cha, scope);
		// CallGraphBuilder builder = Util.makeZeroOneCFABuilder(options, new
		// AnalysisCache(), cha, scope);
		cg = builder.makeCallGraph(options, null);
		sdg = new SDG(cg, builder.getPointerAnalysis(), dOptions, cOptions);
		datadepOptions = dOptions;
		controldepOptions = cOptions;
		prepared = true;
	}

	public static void prepareSDG(String appJar, String mainClass,
			DataDependenceOptions dOptions, ControlDependenceOptions cOptions)
			throws Exception {
		AnalysisScope scope = AnalysisScopeReader.makeJavaBinaryAnalysisScope(
				appJar, (new FileProvider())
						.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));

		// build a class hierarchy, call graph, and system dependence graph
		ClassHierarchy cha = ClassHierarchy.make(scope);
		Iterable<Entrypoint> entrypoints = com.ibm.wala.ipa.callgraph.impl.Util
				.makeMainEntrypoints(scope, cha, mainClass);
		AnalysisOptions options = CallGraphTestUtil.makeAnalysisOptions(scope,
				entrypoints);
		builder = Util.makeVanillaZeroOneCFABuilder(options,
				new AnalysisCache(), cha, scope);
		// CallGraphBuilder builder = Util.makeZeroOneCFABuilder(options, new
		// AnalysisCache(), cha, scope);
		cg = builder.makeCallGraph(options, null);
		sdg = new SDG(cg, builder.getPointerAnalysis(), dOptions, cOptions);
		datadepOptions = dOptions;
		controldepOptions = cOptions;
		prepared = true;
	}

	/**
	 * Compute a slice from a call statements, dot it, and fire off the PDF
	 * viewer to visualize the result
	 * 
	 * @param appJar
	 *            should be something like "c:/temp/testdata/java_cup.jar"
	 * @param mainClass
	 *            should be something like "c:/temp/testdata/java_cup.jar"
	 * @param srcCaller
	 *            name of the method containing the statement of interest
	 * @param srcCallee
	 *            name of the method called by the statement of interest
	 * @param goBackward
	 *            do a backward slice?
	 * @param dOptions
	 *            options controlling data dependence
	 * @param cOptions
	 *            options controlling control dependence
	 * @return a Process running the PDF viewer to visualize the dot'ted
	 *         representation of the slice
	 * @throws Exception
	 */
	public static void sliceFromStmt(String appJar, String mainClass,
			String srcCaller, String srcCallee, boolean goBackward,
			DataDependenceOptions dOptions, ControlDependenceOptions cOptions)
			throws Exception {
		// find the call statement of interest
		if (!prepared)
			prepareSDG(appJar, mainClass, dOptions, cOptions);

		CGNode callerNode = SlicerTest.findMethod(cg, srcCaller);
		Statement s = SlicerTest.findCallTo(callerNode, srcCallee);
		System.err.println("Statement: " + s);

		// compute the slice as a collection of statements
		Collection<Statement> slice = null;
		if (goBackward) {
			slice = Slicer.computeBackwardSlice(s, cg,
					builder.getPointerAnalysis(), dOptions, cOptions);
		} else {
			// for forward slices ... we actually slice from the return value of
			// calls.
			s = getReturnStatementForCall(s);
			slice = Slicer.computeForwardSlice(s, cg,
					builder.getPointerAnalysis(), dOptions, cOptions);
		}
		// SlicerTest.dumpSlice(slice);

		// create a view of the SDG restricted to nodes in the slice
		Graph<Statement> g = pruneSDG(sdg, slice);

		sanityCheck(slice, g);

		for (Statement stmt : slice) {
			// System.out.println(stmt.getClass() + " : " + stmt);

			if (stmt instanceof NormalStatement) {
				System.out.println(stmt);

			}

		}
	}

	/**
	 * check that g is a well-formed graph, and that it contains exactly the
	 * number of nodes in the slice
	 */
	private static void sanityCheck(Collection<Statement> slice,
			Graph<Statement> g) {
		try {
			GraphIntegrity.check(g);
		} catch (UnsoundGraphException e1) {
			e1.printStackTrace();
			Assertions.UNREACHABLE();
		}
		Assertions.productionAssertion(g.getNumberOfNodes() == slice.size(),
				"panic " + g.getNumberOfNodes() + " " + slice.size());
	}

	/**
	 * If s is a call statement, return the statement representing the normal
	 * return from s
	 */
	public static Statement getReturnStatementForCall(Statement s) {
		if (s.getKind() == Kind.NORMAL) {
			NormalStatement n = (NormalStatement) s;
			SSAInstruction st = n.getInstruction();
			if (st instanceof SSAInvokeInstruction) {
				SSAAbstractInvokeInstruction call = (SSAAbstractInvokeInstruction) st;
				if (call.getCallSite().getDeclaredTarget().getReturnType()
						.equals(TypeReference.Void)) {
					throw new IllegalArgumentException(
							"this driver computes forward slices from the return value of calls.\n"
									+ ""
									+ "Method "
									+ call.getCallSite().getDeclaredTarget()
											.getSignature() + " returns void.");
				}
				return new NormalReturnCaller(s.getNode(),
						n.getInstructionIndex());
			} else {
				return s;
			}
		} else {
			return s;
		}
	}

	/**
	 * return a view of the sdg restricted to the statements in the slice
	 */
	public static Graph<Statement> pruneSDG(SDG sdg,
			final Collection<Statement> slice) {
		Filter<Statement> f = new Filter<Statement>() {
			@Override
			public boolean accepts(Statement o) {
				return slice.contains(o);
			}
		};
		return GraphSlicer.prune(sdg, f);
	}

	/**
	 * @return a NodeDecorator that decorates statements in a slice for a
	 *         dot-ted representation
	 */
	public static NodeDecorator makeNodeDecorator() {
		return new NodeDecorator() {
			@Override
			public String getLabel(Object o) throws WalaException {
				Statement s = (Statement) o;
				switch (s.getKind()) {
					case HEAP_PARAM_CALLEE:
					case HEAP_PARAM_CALLER:
					case HEAP_RET_CALLEE:
					case HEAP_RET_CALLER:
						HeapStatement h = (HeapStatement) s;
						return s.getKind() + "\\n" + h.getNode() + "\\n"
								+ h.getLocation();
					case NORMAL:
						NormalStatement n = (NormalStatement) s;
						return n.getInstruction() + "\\n"
								+ n.getNode().getMethod().getSignature();
					case PARAM_CALLEE:
						ParamCallee paramCallee = (ParamCallee) s;
						return s.getKind() + " " + paramCallee.getValueNumber()
								+ "\\n" + s.getNode().getMethod().getName();
					case PARAM_CALLER:
						ParamCaller paramCaller = (ParamCaller) s;
						return s.getKind()
								+ " "
								+ paramCaller.getValueNumber()
								+ "\\n"
								+ s.getNode().getMethod().getName()
								+ "\\n"
								+ paramCaller.getInstruction().getCallSite()
										.getDeclaredTarget().getName();
					case EXC_RET_CALLEE:
					case EXC_RET_CALLER:
					case NORMAL_RET_CALLEE:
					case NORMAL_RET_CALLER:
					case PHI:
					default:
						return s.toString();
				}
			}

		};
	}

	static Set<Unit>	emptyUnits	= new HashSet<Unit>();

	// new API. sliceFromStmt and sliceWholeMethod are old APIs.
	public static Set<Unit> getDependentStmts_final(Body bb, Stmt unit) {
		if (!prepared)
			throw new RuntimeException(
					" I assume you have already prepared the SDG!");
		if (SootHelper.isConstructor(bb.getMethod()))
			throw new RuntimeException(
					"do not analyze the constructor methods, wala may miss some implicitly added constructors.");
		Statement statement = SootWalaBridge.fromSoottoWala(bb, unit);

		Collection<Statement> slice = null;
		// for forward slices ... we actually slice from the return value of
		// calls.
		if (returnVoid(statement))
			return emptyUnits;
		statement = getReturnStatementForCall(statement);
		try {
			slice = Slicer.computeForwardSlice(statement, cg,
					builder.getPointerAnalysis(), datadepOptions,
					controldepOptions);

		} catch (Exception e) {
			e.printStackTrace();
		}

		if (slice == null || slice.size() == 0)
			return emptyUnits;
		return SootWalaBridge.fromWalaToSoot(bb, slice);
	}

	/**
	 * Validate that the command-line arguments obey the expected usage.
	 * 
	 * Usage:
	 * <ul>
	 * <li>args[0] : "-appJar"
	 * <li>args[1] : something like "c:/temp/testdata/java_cup.jar"
	 * <li>args[2] : "-mainClass"
	 * <li>args[3] : something like "Lslice/TestRecursion" *
	 * <li>args[4] : "-srcCallee"
	 * <li>args[5] : something like "print" *
	 * <li>args[4] : "-srcCaller"
	 * <li>args[5] : something like "main"
	 * </ul>
	 * 
	 * @throws UnsupportedOperationException
	 *             if command-line is malformed.
	 */

	private static boolean returnVoid(Statement s) {

		if (s.getKind() == Kind.NORMAL) {
			NormalStatement n = (NormalStatement) s;
			SSAInstruction st = n.getInstruction();
			if (st instanceof SSAInvokeInstruction) {
				SSAAbstractInvokeInstruction call = (SSAAbstractInvokeInstruction) st;
				if (call.getCallSite().getDeclaredTarget().getReturnType()
						.equals(TypeReference.Void)) {
					return true;
				}
			}
		}

		return false;
	}
}